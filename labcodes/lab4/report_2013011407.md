# Lab4 Report

## 练习1

大部分的成员变量都应赋初值0，只有state、pid和cr3应赋值PROC_UNINIT、-1和boot_cr3。所以先memset整个结构体为0，然后对这三个变量分别赋值。

tf为保存的该进程当前的栈帧，context为对应时刻的寄存器的值。这两个变量用于在进程切换时保存上下文相关数据。

## 练习2

先分配进程结构体，然后给进程分配内存管理相关的信息，最后将进程加入进程管理内。

每个进程的pid是唯一的，因为在get_pid函数中会扫描包含所有进程的链表，保证pid不重复。

## 练习3

在用proc_run切换进程的时候，首先切换的是内核栈，然后切换页表（本实验中并没有用到，因为都是内核线程），最后改变上下文。当函数返回时，便会回到新进程的中断点了。

在本实验中，一共创建了两个内核线程。一个是idle，在没有其它进程需要运行时消耗CPU；另一个是Hello world，在屏幕打印一句话后就会退出。

local_intr_save和local_intr_restore用来关中断和开中断，在切换时关中断可以防止在进程切换的途中被时钟中断等打断，引起二次进程切换。

## 与参考答案的比较

原理上并没有不同。但是参考答案在do_fork中把新进程加入进程管理的时候（get_pid、add to process list、add to hash list）关中断了，这样可以避免在添加到一半的时候发生进程切换导致出错的情况。

## 知识点

1. 进程（线程）管理的概念和具体进程管理需要记录哪些信息来进程切换；
2. 通过开关中断来完成一些同步操作，实现类似加锁的功能。