# Lab7 Report

## 练习1

内核信号量的设计：由整型变量value和等待队列wait_queue组成

当请求资源时，调用down函数，在__down中会判断value是否>0，若>0则将value减一并返回，否则将当前线程放入wait_queue并reschedule

当释放资源时，调用up函数，在__up中会判断wait_queue是否为空，若空则将value加一并返回，否则唤醒一个队列中的线程

若要在用户态提供信号量，最简单的方法是设计三个系统调用分别对应信号量的申请、请求和释放三种操作，然后在syscall的处理函数中调用内核态的对应函数即可。与内核信号量相比，因为要通过中断实现，性能会下降。

## 练习2

条件变量和管程的设计：
一个moniter_t中有mutex控制只能有一个线程在管程内执行，信号量next和计数器next_count表示在管程内因发出信号睡眠的线程，条件变量数组cv表示等待某个条件的线程；
一个condvar_t中有信号量sem和计数器count表示等待该条件的线程，owner表示该条件变量所属的管程；

当线程等待条件cv时，先将等待计数器加一，然后让出管程的执行权（优先是因发出信号而睡眠的线程，其次是等待进入管程的线程），最后等待该条件变量的信号量，被唤醒后（此时条件已成立）等待计数器减一；
当线程对条件cv发出信号时，若没有线程在等待，直接返回；若有线程在等待，则将自己加入管程的next的等待队列中，然后让出管程执行权给等待条件cv的线程，当再次被唤醒时将自己从next的等待队列中移出。

若要在用户态提供条件变量，同样可以通过类似信号量的方法，设计申请、等待、唤醒条件变量这三个系统调用来实现。与内核条件变量相比，因为要通过中断实现，性能会下降。

## 与参考答案的比较

实现的原理上与参考答案完全一样，只有一处小区别：
在哲学家就餐中，若一个线程在take_forks时睡眠然后被唤醒，此时就一定已经拿到了两个叉子，因此使用if判断一次即可

## 知识点

1. 管程和条件变量的原理和具体实现（这个在课上被没有详细说明）
2. 管程的使用