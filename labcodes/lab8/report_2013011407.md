# Lab8 Report

## 练习1

共分三部分读取。
首先若第一个block没有边界对齐，则读取未对齐部分。具体过程为先用sfs_bmap_load_nolock获得该block对应的inode，然后通过offset确定要读取的数据长度（此处要特殊处理所有读取的数据都在一个block内的情况），然后通过sys_buf_op来读取数据。
然后读取所有完整的block，此处只需顺序读取每个block即可。具体就是先用上述方法获得inode，然后用sys_block_op来读取整个block。
最后处理末尾block没有边界对齐的情况。具体过程与第一部分完全类似，但是不需要处理特殊情况了。

若要实现pipe，可以考虑实现一个"PIPE_FS"，文件对应管道，并将对应的读写磁盘操作改为读写内存页即可。在写时可能需要加锁来保证一致性。

## 练习2

load_icode的流程其实仍然与前面的lab一致，只是现在需要从磁盘读取binary而已。
因此首先只要在读取elf_headers和TEXT/DATA段的时候从复制内存改为使用load_icode_read读磁盘即可。
其次还有建立用户堆栈。因为此前都是直接通过内核来运行，因此并没有多余的参数，但是现在改为可通过sh来运行命令了，需要在运行程序时在用户堆栈中加入命令行参数。具体过程比较简单，就是在USTACKTOP下构造一个符合要求的栈帧即可。

对于硬链接，只要在sfs_disk_inode中增加引用计数，在建立hard link时将inode指向同一个disk inode即可。
对于软链接，可以通过建立一个新文件，将新文件的内容记为该soft link指向的文件的inode地址。

## 与参考答案的比较

读文件部分并没有任何本质差别。
在load_icode中，建立用户栈时没有判断最长允许的参数长度，这可能是个漏洞，会导致系统受到攻击。

## 知识点

1. 文件系统的原理、操作与实现